<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>clone函数</title>
</head>
<body>


<script>

    var obj = {
        name:'jack',
        friends:['lily','bob'],
        jisu:{
            react:'yes',
            vue:'yes'
        }
    }
    var str = 'hello',num=22,bool=true;

    function clone(param) {
        return param;
    }
    var newStr = clone(str);
    var newNum  = clone(num);
    var newBool = clone(bool);
    var newObj = clone(obj);

    str = 'world';
    num = 33;
    bool = false,
    obj.name = 'rose';
    console.log(newStr)  //仍然返回hello
    console.log(newNum)  //仍然返回22
    console.log(newBool)  //仍然返回22
    console.log(newNum)  //仍然返回true
    console.log(newObj)

    function lightClone (param) {
        if(Object.prototype.toString.call(param) === "[object Array]") {
            return param.slice();   // slice()数组拷贝将返回一个新数组
        }else if(Object.prototype.toString.call(param) === "[object Object]") {
            var o = {}
            for(var key in param) {
                console.log(key)
                if(param.hasOwnProperty(key) === true) { //使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问：
                    o[key] = param[key]
                }
            }
            return o;
        } else {
            return param;
        }
    }
    var newObj1 = lightClone(obj);
    obj.name = 'wesday'
    str = 'new  world'
    
    var newStr1 = lightClone(str)
    console.log('浅拷贝')
    console.log(newObj1)
    console.log(newStr1)
</script>
</body>
</html>